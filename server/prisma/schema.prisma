generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String                  @id @default(cuid())
  clerkId                String?                 @unique
  anonymousId            String                  @unique @default(cuid())
  phoneNumber            String                  @unique
  nickname               String?
  age                    Int?
  gender                 Gender?
  profileImage           String?
  bio                    String?
  isVerified             Boolean                 @default(false)
  credits                Int                     @default(1)
  isPremium              Boolean                 @default(false)
  premiumLevel           PremiumLevel            @default(FREE)
  premiumUntil           DateTime?
  lastActive             DateTime                @default(now())
  lastOnline             DateTime?
  deletedAt              DateTime?
  deletionReason         String?
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  companyName            String?
  education              String?
  location               String?
  interests              String[]
  height                 Int?
  mbti                   String?
  drinking               String?
  smoking                String?
  privacySettings        Json?
  notificationSettings   Json?
  locationProfileMode    String?
  personaProfile         Json?
  personaSettings        Json?
  lastLatitude           Float?
  lastLongitude          Float?
  lastLocationUpdateAt   DateTime?
  locationSharingEnabled Boolean                 @default(false)
  birthdate              String?
  email                  String?
  gameIds                Json?
  major                  String?
  platformIds            Json?
  realName               String?
  school                 String?
  socialIds              Json?
  appearance             String?
  hobbies                String?
  partTimeJob            Json?
  department             String?
  groups                 String[]
  studentId              String?
  sentMessages           ChatMessage[]
  commentLikes           CommentLike[]
  comments               Comment[]
  communityPosts         CommunityPost[]
  verifications          CompanyVerification[]
  emailVerifications     EmailVerification[]
  fcmTokens              FcmToken[]
  feedbackComments       FeedbackComment[]
  feedbackVotes          FeedbackVote[]
  feedbacks              Feedback[]
  files                  File[]
  sentFriendRequests     FriendRequest[]         @relation("SentRequests")
  receivedFriendRequests FriendRequest[]         @relation("ReceivedRequests")
  friendships1           Friendship[]            @relation("User1Friends")
  friendships2           Friendship[]            @relation("User2Friends")
  groupChatMembers       GroupChatMember[]
  groupChatMessages      GroupChatMessage[]
  createdInvites         GroupInvite[]
  groupLikes             GroupLike[]
  groupMemberships       GroupMember[]
  createdGroups          Group[]                 @relation("GroupCreator")
  matchedInterests       InterestSearch[]        @relation("MatchedInterests")
  interestSearches       InterestSearch[]        @relation("UserInterests")
  locationCheckIns       LocationCheckIn[]
  matches1               Match[]                 @relation("User1Matches")
  matches2               Match[]                 @relation("User2Matches")
  messageReactions       MessageReaction[]
  notifications          Notification[]
  payments               Payment[]
  persona                Persona?
  postLikes              PostLike[]
  scheduledNotifications ScheduledNotification[]
  stories                Story[]
  storyViews             StoryView[]
  subscriptions          Subscription[]
  deviceTokens           UserDeviceToken[]
  user_encrypted_data    user_encrypted_data[]
  sentLikes              UserLike[]              @relation("SentLikes")
  receivedLikes          UserLike[]              @relation("ReceivedLikes")
  user_profile_infos     user_profile_infos[]
  callsMade              VideoCall[]             @relation("CallsMade")
  callsReceived          VideoCall[]             @relation("CallsReceived")

  @@map("users")
}

model Persona {
  id         String   @id @default(cuid())
  userId     String   @unique
  nickname   String
  age        Int?
  bio        String?
  interests  String[]
  occupation String?
  height     Int?
  mbti       String?
  drinking   String?
  smoking    String?
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("personas")
}

model UserDeviceToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  platform  String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_device_tokens")
}

model FcmToken {
  id         String   @id @default(cuid())
  userId     String
  token      String   @unique
  deviceType String
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("fcm_tokens")
}

model Company {
  id            String                @id @default(cuid())
  name          String
  domain        String                @unique
  type          CompanyType
  isVerified    Boolean               @default(false)
  logo          String?
  description   String?
  location      String?
  createdAt     DateTime              @default(now())
  verifications CompanyVerification[]
  groups        Group[]

  @@map("companies")
}

model CompanyVerification {
  id          String             @id @default(cuid())
  userId      String
  companyId   String
  method      VerificationMethod
  status      VerificationStatus @default(PENDING)
  data        Json?
  submittedAt DateTime           @default(now())
  reviewedAt  DateTime?
  reviewedBy  String?
  company     Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)
  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("company_verifications")
}

model Group {
  id             String            @id @default(cuid())
  name           String
  description    String?
  type           GroupType
  imageUrl       String?
  isActive       Boolean           @default(true)
  maxMembers     Int?
  creatorId      String?
  companyId      String?
  settings       Json
  location       Json?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  communityPosts CommunityPost[]
  groupChats     GroupChat[]
  groupInvites   GroupInvite[]
  groupLikes     GroupLike[]
  members        GroupMember[]
  company        Company?          @relation(fields: [companyId], references: [id])
  creator        User?             @relation("GroupCreator", fields: [creatorId], references: [id])
  inviteCodes    InviteCode[]
  checkIns       LocationCheckIn[]
  matches        Match[]
  likes          UserLike[]

  @@map("groups")
}

model GroupMember {
  id       String            @id @default(cuid())
  userId   String
  groupId  String
  role     GroupMemberRole   @default(MEMBER)
  status   GroupMemberStatus @default(ACTIVE)
  joinedAt DateTime          @default(now())
  group    Group             @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user     User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId])
  @@map("group_members")
}

model GroupInvite {
  id              String   @id @default(cuid())
  groupId         String
  inviteCode      String   @unique
  createdByUserId String
  expiresAt       DateTime
  maxUses         Int?
  uses            Int      @default(0)
  createdAt       DateTime @default(now())
  createdBy       User     @relation(fields: [createdByUserId], references: [id])
  group           Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@index([inviteCode])
  @@index([expiresAt])
  @@map("group_invites")
}

model InviteCode {
  id        String   @id @default(cuid())
  code      String   @unique
  groupId   String
  createdBy String
  maxUses   Int      @default(1)
  usedCount Int      @default(0)
  expiresAt DateTime
  createdAt DateTime @default(now())
  group     Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@map("invite_codes")
}

model UserLike {
  id                 String             @id @default(cuid())
  fromUserId         String
  toUserId           String
  groupId            String
  isMatch            Boolean            @default(false)
  isSuper            Boolean            @default(false)
  cancelledAt        DateTime?
  deletedAt          DateTime?
  createdAt          DateTime           @default(now())
  relationshipIntent RelationshipIntent
  fromUser           User               @relation("SentLikes", fields: [fromUserId], references: [id], onDelete: Cascade)
  group              Group              @relation(fields: [groupId], references: [id], onDelete: Cascade)
  toUser             User               @relation("ReceivedLikes", fields: [toUserId], references: [id], onDelete: Cascade)

  @@unique([fromUserId, toUserId, groupId])
  @@index([fromUserId, groupId])
  @@index([toUserId, groupId])
  @@index([groupId, createdAt])
  @@map("user_likes")
}

model GroupLike {
  id        String   @id @default(cuid())
  userId    String
  groupId   String
  createdAt DateTime @default(now())
  group     Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId])
  @@index([groupId])
  @@map("group_likes")
}

model Match {
  id                 String             @id @default(cuid())
  user1Id            String
  user2Id            String
  groupId            String
  status             MatchStatus        @default(ACTIVE)
  lastMessageAt      DateTime?
  isActive           Boolean            @default(true)
  createdAt          DateTime           @default(now())
  mismatchedBy       String?
  mismatchedAt       DateTime?
  mismatchReason     String?
  interestType       InterestType
  relationshipIntent RelationshipIntent
  messages           ChatMessage[]
  group              Group              @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user1              User               @relation("User1Matches", fields: [user1Id], references: [id], onDelete: Cascade)
  user2              User               @relation("User2Matches", fields: [user2Id], references: [id], onDelete: Cascade)

  @@unique([user1Id, user2Id, groupId])
  @@map("matches")
}

model ChatMessage {
  id          String            @id @default(cuid())
  matchId     String
  senderId    String
  content     String
  type        MessageType       @default(TEXT)
  isEncrypted Boolean           @default(true)
  readAt      DateTime?
  createdAt   DateTime          @default(now())
  match       Match             @relation(fields: [matchId], references: [id], onDelete: Cascade)
  sender      User              @relation(fields: [senderId], references: [id], onDelete: Cascade)
  reactions   MessageReaction[]

  @@index([matchId, createdAt])
  @@index([senderId])
  @@map("chat_messages")
}

model MessageReaction {
  id        String      @id @default(cuid())
  messageId String
  userId    String
  emoji     String
  createdAt DateTime    @default(now())
  message   ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@map("message_reactions")
}

model VideoCall {
  id         String     @id @default(cuid())
  callerId   String
  receiverId String
  callType   CallType   @default(VIDEO)
  status     CallStatus @default(INITIATED)
  startedAt  DateTime?
  endedAt    DateTime?
  duration   Int?
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  caller     User       @relation("CallsMade", fields: [callerId], references: [id], onDelete: Cascade)
  receiver   User       @relation("CallsReceived", fields: [receiverId], references: [id], onDelete: Cascade)

  @@index([callerId])
  @@index([receiverId])
  @@index([status])
  @@map("video_calls")
}

model Story {
  id        String         @id @default(cuid())
  userId    String
  mediaUrl  String
  mediaType StoryMediaType
  caption   String?
  isActive  Boolean        @default(true)
  expiresAt DateTime
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  user      User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  views     StoryView[]

  @@index([userId])
  @@index([isActive])
  @@index([expiresAt])
  @@map("stories")
}

model StoryView {
  id       String   @id @default(cuid())
  storyId  String
  viewerId String
  viewedAt DateTime @default(now())
  story    Story    @relation(fields: [storyId], references: [id], onDelete: Cascade)
  viewer   User     @relation(fields: [viewerId], references: [id], onDelete: Cascade)

  @@unique([storyId, viewerId])
  @@index([storyId])
  @@index([viewerId])
  @@map("story_views")
}

model Payment {
  id              String        @id @default(cuid())
  userId          String
  amount          Int
  currency        String        @default("KRW")
  type            PaymentType
  status          PaymentStatus @default(PENDING)
  method          PaymentMethod
  stripePaymentId String?
  metadata        Json?
  createdAt       DateTime      @default(now())
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status])
  @@index([status, createdAt])
  @@map("payments")
}

model Subscription {
  id                   String             @id @default(cuid())
  userId               String
  plan                 SubscriptionPlan
  status               SubscriptionStatus @default(ACTIVE)
  stripeCustomerId     String?
  stripeSubscriptionId String?
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  data      Json?
  isRead    Boolean          @default(false)
  readAt    DateTime?
  createdAt DateTime         @default(now())
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model ScheduledNotification {
  id          String    @id @default(cuid())
  userId      String
  title       String
  body        String
  data        Json?
  scheduledAt DateTime
  sent        Boolean   @default(false)
  sentAt      DateTime?
  createdAt   DateTime  @default(now())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("scheduled_notifications")
}

model LocationCheckIn {
  id        String              @id @default(cuid())
  userId    String
  groupId   String
  latitude  Float
  longitude Float
  accuracy  Float
  method    LocationCheckMethod
  isValid   Boolean             @default(true)
  createdAt DateTime            @default(now())
  group     Group               @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user      User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("location_check_ins")
}

model File {
  id           String   @id @default(cuid())
  filename     String
  originalName String
  mimeType     String
  size         Int
  url          String
  path         String?
  uploadedBy   String?
  userId       String?
  category     String?
  metadata     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User?    @relation(fields: [userId], references: [id])

  @@map("files")
}

model CommunityPost {
  id           String     @id @default(cuid())
  authorId     String
  groupId      String
  title        String
  content      String
  imageUrls    String[]
  viewCount    Int        @default(0)
  likeCount    Int        @default(0)
  commentCount Int        @default(0)
  isPinned     Boolean    @default(false)
  category     String?
  tags         String[]
  isDeleted    Boolean    @default(false)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  comments     Comment[]
  author       User       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  group        Group      @relation(fields: [groupId], references: [id], onDelete: Cascade)
  likes        PostLike[]

  @@index([groupId, createdAt])
  @@index([authorId])
  @@map("community_posts")
}

model Comment {
  id        String        @id @default(cuid())
  postId    String
  authorId  String
  content   String
  parentId  String?
  likeCount Int           @default(0)
  isDeleted Boolean       @default(false)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  likes     CommentLike[]
  author    User          @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent    Comment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[]     @relation("CommentReplies")
  post      CommunityPost @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([parentId])
  @@map("comments")
}

model PostLike {
  id        String        @id @default(cuid())
  postId    String
  userId    String
  createdAt DateTime      @default(now())
  post      CommunityPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@map("post_likes")
}

model CommentLike {
  id        String   @id @default(cuid())
  commentId String
  userId    String
  createdAt DateTime @default(now())
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([commentId, userId])
  @@map("comment_likes")
}

model Feedback {
  id        String            @id @default(cuid())
  userId    String
  title     String
  content   String
  category  String
  priority  String            @default("medium")
  status    String            @default("pending")
  voteCount Int               @default(0)
  isActive  Boolean           @default(true)
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  comments  FeedbackComment[]
  votes     FeedbackVote[]
  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([category])
  @@map("feedbacks")
}

model FeedbackVote {
  id         String   @id @default(cuid())
  feedbackId String
  userId     String
  voteType   String
  createdAt  DateTime @default(now())
  feedback   Feedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, feedbackId])
  @@map("feedback_votes")
}

model FeedbackComment {
  id         String   @id @default(cuid())
  feedbackId String
  userId     String
  content    String
  createdAt  DateTime @default(now())
  feedback   Feedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([feedbackId])
  @@map("feedback_comments")
}

model FAQ {
  id        String   @id @default(cuid())
  question  String
  answer    String
  category  String
  order     Int      @default(0)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([order])
  @@map("faqs")
}

model GroupChat {
  id            String             @id @default(cuid())
  groupId       String
  name          String
  description   String?
  imageUrl      String?
  maxMembers    Int                @default(50)
  isPublic      Boolean            @default(true)
  lastMessageAt DateTime?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  members       GroupChatMember[]
  messages      GroupChatMessage[]
  group         Group              @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@index([groupId])
  @@map("group_chats")
}

model GroupChatMember {
  id         String        @id @default(cuid())
  chatId     String
  userId     String
  role       GroupChatRole @default(MEMBER)
  joinedAt   DateTime      @default(now())
  lastReadAt DateTime?
  chat       GroupChat     @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user       User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([chatId, userId])
  @@index([userId])
  @@map("group_chat_members")
}

model GroupChatMessage {
  id          String             @id @default(cuid())
  chatId      String
  senderId    String
  content     String
  type        GroupMessageType   @default(TEXT)
  isEncrypted Boolean            @default(true)
  replyToId   String?
  createdAt   DateTime           @default(now())
  chat        GroupChat          @relation(fields: [chatId], references: [id], onDelete: Cascade)
  replyTo     GroupChatMessage?  @relation("MessageReplies", fields: [replyToId], references: [id])
  replies     GroupChatMessage[] @relation("MessageReplies")
  sender      User               @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([chatId, createdAt])
  @@map("group_chat_messages")
}

model InterestSearch {
  id                                                               String              @id @default(cuid())
  userId                                                           String
  type                                                             InterestType
  value                                                            String
  metadata                                                         Json?
  status                                                           SearchStatus        @default(ACTIVE)
  matchedWithId                                                    String?
  matchedAt                                                        DateTime?
  expiresAt                                                        DateTime?
  createdAt                                                        DateTime            @default(now())
  updatedAt                                                        DateTime            @updatedAt
  gender                                                           Gender?
  deletedAt                                                        DateTime?
  deviceId                                                         String?
  hashedPrimary                                                    String?
  isLocalOnly                                                      Boolean             @default(false)
  relationshipIntent                                               RelationshipIntent  @default(ROMANTIC)
  targetGender                                                     Gender?
  primaryHash                                                      String?
  secondaryHash                                                    String?
  encryptedData                                                    String?
  encryptedIV                                                      String?
  encryptedTag                                                     String?
  displayValue                                                     String?
  phoneCountryCode                                                 String?
  phoneLastDigits                                                  String?
  emailDomain                                                      String?
  emailFirstChar                                                   String?
  socialPlatform                                                   String?
  birthYear                                                        Int?
  ageRange                                                         String?
  locationCity                                                     String?
  companyDomain                                                    String?
  schoolName                                                       String?
  partTimeCategory                                                 String?
  platformName                                                     String?
  gameTitle                                                        String?
  matchedWith                                                      User?               @relation("MatchedInterests", fields: [matchedWithId], references: [id])
  user                                                             User                @relation("UserInterests", fields: [userId], references: [id], onDelete: Cascade)
  potential_matches_potential_matches_search1IdTointerest_searches potential_matches[] @relation("potential_matches_search1IdTointerest_searches")
  potential_matches_potential_matches_search2IdTointerest_searches potential_matches[] @relation("potential_matches_search2IdTointerest_searches")

  @@index([type, primaryHash, status])
  @@index([userId, status])
  @@index([relationshipIntent, status])
  @@index([type, value])
  @@map("interest_searches")
}

model EmailLog {
  id       String   @id @default(cuid())
  to       String
  subject  String
  provider String
  status   String
  sent_at  DateTime @default(now())
  metadata Json?

  @@map("email_logs")
}

model SMSLog {
  id          String   @id @default(cuid())
  phoneNumber String
  message     String
  messageType String
  provider    String
  status      String
  metadata    Json?
  createdAt   DateTime @default(now())

  @@index([phoneNumber])
  @@index([status])
  @@index([createdAt])
  @@map("sms_logs")
}

model CompanyDomain {
  id            String   @id @default(cuid())
  domain        String   @unique
  companyName   String
  companyNameKr String?
  isVerified    Boolean  @default(true)
  employeeCount Int?
  industry      String?
  logoUrl       String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([domain])
  @@index([isVerified])
  @@map("company_domains")
}

model EmailVerification {
  id          String    @id @default(cuid())
  userId      String
  email       String
  domain      String
  code        String
  isVerified  Boolean   @default(false)
  expiresAt   DateTime
  verifiedAt  DateTime?
  attempts    Int       @default(0)
  maxAttempts Int       @default(3)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  user        User      @relation(fields: [userId], references: [id])

  @@unique([userId, email])
  @@index([email])
  @@index([code])
  @@index([expiresAt])
  @@map("email_verifications")
}

model FriendRequest {
  id         String              @id @default(cuid())
  fromUserId String
  toUserId   String
  message    String?
  status     FriendRequestStatus @default(PENDING)
  createdAt  DateTime            @default(now())
  updatedAt  DateTime            @updatedAt
  fromUser   User                @relation("SentRequests", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser     User                @relation("ReceivedRequests", fields: [toUserId], references: [id], onDelete: Cascade)

  @@unique([fromUserId, toUserId])
  @@index([toUserId, status])
  @@map("friend_requests")
}

model Friendship {
  id        String   @id @default(cuid())
  user1Id   String
  user2Id   String
  createdAt DateTime @default(now())
  user1     User     @relation("User1Friends", fields: [user1Id], references: [id], onDelete: Cascade)
  user2     User     @relation("User2Friends", fields: [user2Id], references: [id], onDelete: Cascade)

  @@unique([user1Id, user2Id])
  @@index([user2Id])
  @@map("friendships")
}

model potential_matches {
  id                                                               String               @id
  search1Id                                                        String
  search2Id                                                        String
  matchType                                                        InterestType
  matchStrength                                                    Float                @default(100)
  status                                                           PotentialMatchStatus @default(PENDING)
  isConfirmed                                                      Boolean              @default(false)
  confirmedAt                                                      DateTime?
  chatEnabled                                                      Boolean              @default(false)
  chatStartedAt                                                    DateTime?
  createdAt                                                        DateTime             @default(now())
  updatedAt                                                        DateTime
  interest_searches_potential_matches_search1IdTointerest_searches InterestSearch       @relation("potential_matches_search1IdTointerest_searches", fields: [search1Id], references: [id])
  interest_searches_potential_matches_search2IdTointerest_searches InterestSearch       @relation("potential_matches_search2IdTointerest_searches", fields: [search2Id], references: [id])

  @@unique([search1Id, search2Id])
  @@index([status, isConfirmed])
}

model user_encrypted_data {
  id            String   @id
  userId        String
  deviceId      String
  encryptedBlob String
  dataType      String
  lastSyncedAt  DateTime @default(now())
  version       Int      @default(1)
  createdAt     DateTime @default(now())
  updatedAt     DateTime
  users         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, deviceId, dataType])
}

model user_profile_infos {
  id           String            @id
  userId       String
  infoType     ProfileInfoType
  hashedValue1 String
  hashedValue2 String?
  hashedValue3 String?
  displayValue String?
  visibility   ProfileVisibility @default(MATCH_ONLY)
  isVerified   Boolean           @default(false)
  verifiedAt   DateTime?
  priority     Int               @default(0)
  isActive     Boolean           @default(true)
  expiresAt    DateTime?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime
  users        User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([hashedValue1])
  @@index([userId, infoType, isActive])
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum PremiumLevel {
  FREE
  BASIC
  UPPER
}

enum CompanyType {
  COMPANY
  UNIVERSITY
  ORGANIZATION
}

enum VerificationMethod {
  EMAIL_DOMAIN
  OCR_VERIFICATION
  INVITE_CODE
  HR_APPROVAL
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

enum GroupType {
  OFFICIAL
  CREATED
  INSTANCE
  LOCATION
}

enum GroupMemberRole {
  MEMBER
  ADMIN
  CREATOR
}

enum GroupMemberStatus {
  ACTIVE
  PENDING
  BANNED
}

enum MatchStatus {
  ACTIVE
  EXPIRED
  DELETED
  MISMATCH
}

enum RelationshipIntent {
  FRIEND
  ROMANTIC
}

enum CallType {
  VIDEO
  AUDIO
}

enum CallStatus {
  INITIATED
  RINGING
  CONNECTED
  ENDED
  MISSED
  REJECTED
}

enum MessageType {
  TEXT
  IMAGE
  SYSTEM
}

enum StoryMediaType {
  IMAGE
  VIDEO
}

enum PaymentType {
  PREMIUM_SUBSCRIPTION
  LIKE_CREDITS
}

enum SubscriptionPlan {
  MONTHLY
  YEARLY
  LIFETIME
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
  PENDING
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum PaymentMethod {
  CARD
  KAKAO_PAY
  TOSS_PAY
  NAVER_PAY
}

enum NotificationType {
  LIKE_RECEIVED
  MATCH_CREATED
  MESSAGE_RECEIVED
  GROUP_INVITATION
  VERIFICATION_APPROVED
  VERIFICATION_REJECTED
  PAYMENT_SUCCESS
  SUBSCRIPTION_CANCELLED
}

enum LocationCheckMethod {
  GPS
  QR_CODE
}

enum GroupChatRole {
  ADMIN
  MODERATOR
  MEMBER
}

enum GroupMessageType {
  TEXT
  IMAGE
  SYSTEM
  EMOJI
}

enum InterestType {
  PHONE
  EMAIL
  SOCIAL_ID
  BIRTHDATE
  GROUP
  LOCATION
  NICKNAME
  COMPANY
  SCHOOL
  PART_TIME_JOB
  PLATFORM
  GAME_ID
  LIKE
}

enum SearchStatus {
  ACTIVE
  MATCHED
  EXPIRED
  CANCELLED
  DELETED
}

enum FriendRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum PotentialMatchStatus {
  PENDING
  CONFIRMED
  EXPIRED
  REJECTED
}

enum ProfileInfoType {
  PHONE
  EMAIL
  KAKAO_ID
  INSTAGRAM
  FACEBOOK
  TWITTER
  TIKTOK
  DISCORD
  SLACK
  TELEGRAM
  LINE
  WHATSAPP
  GAME_LOL
  GAME_PUBG
  GAME_OVERWATCH
  GAME_VALORANT
  BIRTHDATE
  REALNAME
  MBTI
  HEIGHT
  COMPANY
  SCHOOL
  MAJOR
  DEPARTMENT
  HOBBY
  PART_TIME
  GROUP
}

enum ProfileVisibility {
  PRIVATE
  MATCH_ONLY
  GROUP
  PUBLIC
}
